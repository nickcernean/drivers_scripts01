import string
import random
import binascii

r = 'abcdef'
sequence_names = []

# this function generates a string for the sequence name in the device, it uses the hex values for the sequence

def sequence_name_generator():
    a = ""
    for i in range(0, 36):
        if i == 8 or i == 13 or i == 18 or i == 23:
            a += "-"
        else:
            b = random.choice(r + string.digits)
            a += b.lower()
    # print(a)
    return a


# this function gives the title of the command, the name for the sequence

def sequence_caption_generator(input1):
    b = "Input " + str(input1+1) + " Mute on"
    return b


# this function will generate the command in ASCII characters and then transform it into bytes so that it can be
# transformed into the hex values, then the resulting string is decoded from bytes into a string and capitalized
# the command
# Carriage Return "\r", Line Feed "\n"

def data_generator(input1):
    true_number = str(input1+1)
    d = "" + str(true_number)

    #if input1 >= 9:
       #d = "MUTE OFF TX " + str(true_number) + ""
    #elif input1 <= 8:
       # d = "MUTE OFF TX 0" + str(true_number) + ""

    # the following line will put the output in bytes
    d = bytes(d, 'utf-8')
    # this line transforms the command into HEX code
    d = binascii.hexlify(d)
    # it then is returned to string format
    d = d.decode('utf-8')
    # and then put in ALL UPPER CASE as following a normal sequence generated by the device editor
    d = d.upper()
    # Command in the hexadecimal format
    # d = "30313234" + d + "0D"
    # print(d)
    return d

# the second command
def data_generator2(input1):
    true_number = str(input1+1)
    if true_number > '9':
        true_number = '1' + str(-10 + input1 + 1)
    d = "0PMprf\n"
    # the following line will put the output in bytes
    d = bytes(d, 'utf-8')
    # this line transforms the command into HEX code
    d = binascii.hexlify(d)
    # it then is returned to string format
    d = d.decode('utf-8')
    # and then put in ALL UPPER CASE as following a normal sequence generated by the device editor
    d = d.upper()
    # d = "1B" + d
    # print(d)
    return d

# Sequence Type to SOURCE OR CONTROL ????
# uncomment the data_generator2 if needed

def sequence_generator(input1):
    a = str(sequence_name_generator())
    sequence_names.append(a)
    c = "            <Sequence Name=\"" + a + "\""
    c += " Caption=\"" + str(sequence_caption_generator(input1)) + "\""
    c += " DeviceMenu=\"True\" ProjectMenu=\"True\" Selectable=\"True\" SequenceType=\"Control\" Deletable=\"True\" " \
        "HasData=\"False\" UseHeaderFooter=\"True\">\n              "
    b = str(sequence_name_generator())
    c += "<Reply Name=\"" + b + "\" Caption=\"Reply\" DeviceMenu=\"True\" " \
         "ProjectMenu=\"True\" Selectable=\"True\" SequenceType=\"Reply\" UseHeaderFooter=\"True\">\n"
    c += "                <Image />\n"
    c += "                <Command>\n"
    c += "                  <Data1 />\n"
    c += "                  <SeekOffset Value=\"0\" />\n"
    c += "                </Command>\n"
    c += "              </Reply>\n"
    c += "              <Description />\n"
    c += "              <Image />\n"
    c += "              <Command>\n"
    c += "                <Data1>" + data_generator(input1) + "</Data1>\n"
    # c += "                <Data2>" + data_generator2(input1) + "</Data2>\n"
    c += "                <Data2 />\n"  # This can be changed if data 2 is not needed
    c += "                <Lock1 Value=\"0\" />\n"
    c += "                <Lock2 Value=\"0\" />\n"
    c += "              </Command>\n"
    c += "            </Sequence>\n"
    # print(c)
    return c


def set_generator(count):
    result = "dasd"
    for i in range(0, count):
        result += sequence_generator(i)
    file = "C:/Users/Nicolae.Cernean/OneDrive - Biamp Systems/Desktop/Result.txt"
    with open(file, 'w') as destination:
        destination.write(result)
    print(result)
    return result

# insert the number range for generating the commands
# set_generator()<---- the number here

if __name__ == '__main__':

    print(sequence_name_generator())
    print(len(sequence_name_generator()))
#the real number, counting from 1
