import string
import random
import binascii

r = 'abcdef'
sequence_names_1, sequence_names_2, sequence_names_3 = [], [], []

# this function generates a string for the sequence name in the device, it uses the hex values for the sequence


def sequence_name_generator():
    a = ""
    for i in range(0, 36):
        if i == 8 or i == 13 or i == 18 or i == 23:
            a += "-"
        else:
            c = random.choice(r + string.digits)
            a += c.lower()
    # print(a)
    return a


# this function will give the proper name to the sequences

def sequence_caption_generator(input1, stat):
    s = ""
    if stat == "on":
        s = "AV Mute On Output "
    elif stat == "off":
        s = "AV Mute Off Output "
    elif stat == "K":
        s = "Kill Macro"
    sc = str(s) + str(input1+1)
    return sc


# this function will generate the command in ASCII characters and then transform it into bytes so that it can be
# transformed into the hex values, then the resulting string is decoded from bytes into a string and capitalized


def data_generator(input1, state):
    # true_number = ''
    # if input1 >= 9:
    #     true_number = '1' + str(-10 + input1 + 1)
    # else:
    #     true_number = '0' + str(input1+1)
    d = "x" + str(input1+1) + "$ " + str(state) + "\r"
    # the following line will put the output in bytes
    d = bytes(d, 'utf-8')
    # this line transforms the command into HEX code
    d = binascii.hexlify(d)
    # it then is returned to string format
    d = d.decode('utf-8')
    # and then put in ALL UPPER CASE as following a normal sequence generated by the device editor
    d = d.upper()
    # d = "1B" + d
    # print(d)
    return d


def sequence_generator(input1, state):
    a = str(sequence_name_generator())
    if state == "on":
        sequence_names_1.append(a)
    elif state == "off":
        sequence_names_2.append(a)
    elif state == 2:
        sequence_names_3.append(a)
    c = "            <Sequence Name=\"" + a + "\""
    c += " Caption=\"" + str(sequence_caption_generator(input1, state)) + "\""
    c += " DeviceMenu=\"True\" ProjectMenu=\"True\" Selectable=\"True\" SequenceType=\"Control\" Deletable=\"True\" " \
        "HasData=\"False\" UseHeaderFooter=\"True\">\n              "
    b = str(sequence_name_generator())
    c += "<Reply Name=\"" + b + "\" Caption=\"Reply\" DeviceMenu=\"True\" " \
         "ProjectMenu=\"True\" Selectable=\"True\" SequenceType=\"Reply\" UseHeaderFooter=\"True\">\n"
    c += "                <Image />\n"
    c += "                <Command>\n"
    c += "                  <Data1 />\n"
    c += "                  <SeekOffset Value=\"0\" />\n"
    c += "                </Command>\n"
    c += "              </Reply>\n"
    c += "              <Description />\n"
    c += "              <Image />\n"
    c += "              <Command>\n"
    c += "                <Data1>" + data_generator(input1, state) + "</Data1>\n"
    c += "                <Data2 />\n"
    c += "                <Lock1 Value=\"0\" />\n"
    c += "                <Lock2 Value=\"0\" />\n"
    c += "              </Command>\n"
    c += "            </Sequence>\n"
    # print(c)
    return c


# _________________________________________________________________________________
# __________________________________________________________________________________


def reply_data_generator(state, count):
    e = ""
    if state == "on":
        e += "x" + str(count+1) + "$ on"
    elif state == "off":
        e += "x" + str(count + 1) + "$ off"
    # the following line will put the output in bytes
    e = bytes(e, 'utf-8')
    # this line transforms the command into HEX code
    e = binascii.hexlify(e)
    # it then is returned to string format
    e = e.decode('utf-8')
    # and then put in ALL UPPER CASE as following a normal sequence generated by the device editor
    e = e.upper()
    # print(d)
    return e


def question_generator(count):
    e = "x" + str(count+1) + "$ sta\r"
    # the following line will put the output in bytes
    e = bytes(e, 'utf-8')
    # this line transforms the command into HEX code
    e = binascii.hexlify(e)
    # it then is returned to string format
    e = e.decode('utf-8')
    # and then put in ALL UPPER CASE as following a normal sequence generated by the device editor
    e = e.upper()
    # e = "1B" + e
    # print(d)
    return e

# this function will give the proper name to the sequences


def sequence_caption_generator_feedback(state):
    b = ""
    if state == "off":
        b = "AV Mute off"
    elif state == "on":
        b = "AV Mute on"
    elif state == 2:
        b = "Video and Sync Mute on"
    elif state == "ON":
        b = "Audio Mute on"
    return b


def mapped_seq_selector(count, state):
    res = ''
    print(count)
    if state == "on":
        res = sequence_names_1[count]
    elif state == "off":
        res = sequence_names_2[count]
    elif state == "#":
        res = sequence_names_3[count]
    return res


def reply_generator(state, count):
    d = "                <Reply Caption=\"" + sequence_caption_generator_feedback(state) + "\" Guid=\""
    d += str(sequence_name_generator()) + "\">\n"
    d += "                  <Data>" + str(reply_data_generator(state, count)) + "</Data>\n"
    d += "                  <MappedToSeq Value=\"" + str(mapped_seq_selector(count, state)) + "\" />\n"
    d += "                </Reply>\n"
    return d


def feedback_sequence_generator(count, states=[]):
    # this is the string to request the feedback from the machine: in this case the MCA-88Xi
    offset = 0
    if count+1 >= 10:
        offset = 0
    request = question_generator(count)
    result = "            <FeedbackSequence Name=\"" + str(sequence_name_generator())
    result += "\" Caption=\"Mute status Group " + str(count+1) + "\"" + " Mode=\"Pull\" " \
              "UseHeaderFooter=\"True\">\n"
    result += "              <RequestCommand>" + request + "</RequestCommand>\n"
    result += "              <RequestInterval Value=\"3000\" />\n"
    result += "              <ReplyDataType Value=\"String\" />\n"
    result += "              <ReplyNumberRange Min=\"0\" Max=\"0\" />\n"
    result += "              <ReplyByteOffset Value=\"" + str(offset) + "\" />\n"
    # <-------- Reply offset for feedback search
    result += "              <ReplyValueType Value=\"\" />\n"
    result += "              <ReplyValueFormat Value=\"\" />\n"
    result += "              <ReplyThousandSeperator Value=\"\" />\n"
    result += "              <ReplyTimeFormat Value=\"\" />\n"
    result += "              <ReplyByteOrder Value=\"\" />\n"
    result += "              <ReplyMaxNumberOfBytesForValue Value=\"\" />\n"
    result += "              <Replies>\n"
    for y in range(0, states.__len__()):
            result += str(reply_generator(states[y], count))
    result += "              </Replies>\n"
    result += "            </FeedbackSequence>\n"

    return result


def set_generator(count, states=[]):
    result = ""
    for j in range(0, states.__len__()):
        for i in range(0, count):
            result += sequence_generator(i, states[j])
    file = "C:/Users/fhu/Desktop/Result.txt"
    with open(file, 'w') as destination:
        destination.write(result)
    result_final = ''
    for k in range(0, count):
        result_final += feedback_sequence_generator(k, states)
    file2 = "C:/Users/fhu/Desktop/Feedback.txt"
    with open(file2, 'w') as destination:
        destination.write(result_final)
        destination.close()
    return result


if __name__ == '__main__':
    states_main = ["on", "off"]
    set_generator(2, states_main)
