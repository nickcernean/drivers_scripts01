import string
import random
import binascii

r = 'abcdef'
sequence_names = []


# this function generates a string for the sequence name in the device, it uses the hex values for the sequence

def letters(n):
    if (n < 10):
        return str(n)
    elif (n == 10):
        return "A"
    elif (n == 11):
        return "B"
    elif (n == 12):
        return "C"
    elif (n == 13):
        return "D"
    elif (n == 14):
        return "E"
    elif (n == 15):
        return "F"
    else:
        return letters(n // 16) + letters(n % 16)


def zero(n):
    if (n > 15):
        return letters(n)
    else:
        return "0" + letters(n)


def sequence_name_generator():
    a = ""
    for i in range(0, 36):
        if i == 8 or i == 13 or i == 18 or i == 23:
            a += "-"
        else:
            b = random.choice(r + string.digits)
            a += b.lower()
    # print(a)
    return a


# this function gives the title of the command, the name for the sequence

def sequence_caption_generator(input1):
    b = "Switch Layer Screen" + " 12 " + "Input " + str(input1 + 1)
    return b


# this function will generate the command in ASCII characters and then transform it into bytes so that it can be
# transformed into the hex values, then the resulting string is decoded from bytes into a string and capitalized
# the command
# Carriage Return "\r", Line Feed "\n"

def data_generator(count, starting_point):
    d = "[{\"cmd\":\"W0506\",\"deviceId\":0,\"screenId\":5,\"layerId\":" + str(starting_point) + ",\"inputId\":" + str(
        count) + ",\"interfaceType\":0,\"cropId\":255}]"  # <---- changes can be made here

    # if count > 8:
    #    d = "*255AVO" + str(count+1) + "V0" + str(starting_point) + "!\r"

    # the following line will put the output in bytes
    d = bytes(d, 'utf-8')
    # this line transforms the command into HEX code
    d = binascii.hexlify(d)
    # it then is returned to string format
    d = d.decode('utf-8')
    # and then put in ALL UPPER CASE as following a normal sequence generated by the device editor
    d = d.upper()
    # d = "1B" + str(d)
    # print(d)

    return d


# define the number of byte on which the starting_point starts and ends
# offset1 is the start byte
# offset2 is the end byte

def sequence_generator(count):
    a = str(sequence_name_generator())
    sequence_names.append(a)
    # change offset here

    offset1 = 53
    offset2 = 53

    # if the number before the starting count point is two digits

    if count > 8:
        offset1 = 53
        offset2 = 53
    c = "            <Sequence Name=\"" + a + "\""
    c += " Caption=\"" + str(sequence_caption_generator(count)) + "\""
    c += " DeviceMenu=\"True\" ProjectMenu=\"True\" Selectable=\"True\" Deletable=\"True\" SequenceType=\"Volume\" " \
         " UseHeaderFooter=\"True\">\n" \
         "              <Description />\n"
    c += "              <Image />\n" \
         "              <Type Value=\"InDecrement\" />\n"
    c += "              <Command>\n"
    # put the number you start from !(data_generator(count, THE VALUE SHOULD BE PLACED HERE!))
    c += "                <Data1>" + data_generator(count, 0) + "</Data1>\n"  # <------ 2nd param = minimum value
    c += "                <Data2 />\n" \
         "                <Data3 />\n" \
         "                <Data4 />\n" \
         "                <CountStart Value=\"" + str(
        offset1) + "\" />\n"  # <------ Count byte that changes!! #No changes here
    c += "                <CountStop Value=\"" + str(offset2) + "\" />\n"  # <------ End of Count byte #No chnages here
    c += "                <SecondCountStart Value=\"0\" />\n" \
         "                <SecondCountStop Value=\"0\" />\n" \
         "                <Delay Value=\"100\" />\n" \
         "                <Delay2 Value=\"100\" />\n"
    # minimum value
    c += "                <MinimumVolume Value=\"0\" />\n"  # <----- Min VALUE !!!
    # maximum value
    c += "                <MaximumVolume Value=\"100\" />\n"  # Max VALUE !!!!
    # volume step value
    c += "                <VolumeStep Value=\"1\" />\n" \
         "                <RepeatSpeed Value=\"100\" />\n"  # <------ Repeat speed for inc/dec level # <------ CHANGE TO LSB AND STRING BELLOW
    # CountType to String or Binary
    c += "                <CountType Value=\"String\" />\n" \
         "                <ByteOrder Value=\"MSB\" />\n" \
         "                <CheckSum Name=\"None\" Caption=\"None\" Value=\"None\">\n" \
         "                  <Type>_</Type>\n" \
         "                  <FromByte>0</FromByte>\n"
    c += "                  <ToByte>0</ToByte>\n" \
         "                  <TargetByte>0</TargetByte>\n" \
         "                  <CRCPoly>0</CRCPoly>\n" \
         "                  <CRCIntVal>0</CRCIntVal>\n" \
         "                  <CRCFinalXorVal>0</CRCFinalXorVal>\n" \
         "                  <CRCRevDataByte>0</CRCRevDataByte>\n" \
         "                  <CRCRevFinalCRC>0</CRCRevFinalCRC>\n" \
         "                  <CRCBitNumber>0</CRCBitNumber>\n" \
         "                </CheckSum>\n"
    c += "                <CountFormat Value=\"String\" />\n" \
         "                <PlusForPositive>False</PlusForPositive>\n"  # Change to True or False
    c += "                <AddLeadingZeros>False</AddLeadingZeros>\n"  # Change to True or False
    c += "              </Command>\n" \
         "            </Sequence>\n"

    return c


# the Fedback replies here are not working, if you need to create the feedback for that commands go to feedback_replicator_level_command.py

# ______________________________________________________________________________
# ______________________________________________________________________________
# ______________________________________________________________________________
# ______________Feedback section begins here____________________________________
# ______________________________________________________________________________


def reply_caption_generator(count):
    b = "AI-1 Gain Input " + str(count + 1) + " level"
    return b


def question_generator(count):
    e = "/PARAM/DSP/ANALOGIN_1/GAIN/IDX" + str(count + 1) + " ?"
    # e = "< GET " + str(count+1) + "AUDIO_GAIN_HI_RES >"   # <-------------- POSSIBLE CHANGE HERE
    # if count > 8:
    #    e = "*255AFO" + str(count+1) + "!\r"
    # the following line will put the output in bytes
    e = bytes(e, 'utf-8')
    # this line transforms the command into HEX code
    e = binascii.hexlify(e)
    # it then is returned to string format
    e = e.decode('utf-8')
    # and then put in ALL UPPER CASE as following a normal sequence generated by the device editor
    e = e.upper()
    # e = "1B" + str(e)
    # print(d)
    return e


def reply_generator(count):
    a = str(sequence_name_generator())

    of = 32
    # if count > 8:
    #    of = 26
    res = "            <FeedbackSequence Name=\"" + a + "\" Caption=\"" + str(reply_caption_generator(count))
    res += "\" Mode=\"Pull\" UseHeaderFooter=\"True\">\n"
    res += "              <RequestCommand\"" + str(question_generator(count)) + "/>\n"
    res += "              <RequestInterval Value=\"3000\" />\n"
    res += "              <ReplyDataType Value=\"NumberRange\" />\n"
    # ______________________________________________________________________________
    # _________________CHANGE NUMBER RANGE HERE !!!_________________________________
    # ______________________________________________________________________________
    res += "              <ReplyNumberRange Min=\"-80\" Max=\"20\" />\n"
    res += "              <ReplyByteOffset Value=\"" + str(of) + "\" />\n"
    res += "              <ReplyValueType Value=\"String\" />\n"
    res += "              <ReplyValueFormat Value=\"Decimal\" />\n"
    res += "              <ReplyThousandSeperator Value=\"None\" />\n"
    res += "              <ReplyTimeFormat Value=\"\" />\n"
    res += "              <ReplyByteOrder Value=\"\" />\n"
    res += "              <ReplyMaxNumberOfBytesForValue Value=\"Unknown\" />\n"
    res += "              <Replies>\n"
    res += "                <Reply Caption=\"Input " + str(count + 1) + " level reply\" Guid=\"" + \
           str(sequence_name_generator()) + "\">\n"
    res += "                  <Data=\" lalalala\" />\n"
    res += "                  <MappedToSeq Value=\"" + sequence_names[count] + "\" />\n"
    res += "                </Reply>\n"
    res += "              </Replies>\n"
    res += "            </FeedbackSequence>\n"
    return res


if __name__ == '__main__':
    result_final = ''
    feedback_res = ''

    # say the range, the amount of the commands

    for i in range(0, 8):
        result_final += sequence_generator(i)
        # feedback_res += reply_generator(i)

    file2 = "C:/Users/Nicolae.Cernean/OneDrive - Biamp Systems/Desktop/Result.txt"
    with open(file2, 'w') as destination:
        destination.write(result_final)
        destination.close()

    #    file2 = "C:/Users/Nicolae.Cernean/OneDrive - Biamp Systems/Desktop/Feedback.txt"
    # with open(file2, 'w') as destination:
    # destination.write(feedback_res)
